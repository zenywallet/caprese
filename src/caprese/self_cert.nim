# Copyright (c) 2024 zenywallet

import std/algorithm
import std/times
import std/os
import bytes
import openssl
import bearssl/bearssl_ssl
import bearssl/bearssl_rsa
import bearssl/bearssl_x509

const curSrcPath = currentSourcePath.parentDir()

type
  SelfCertError* = object of CatchableError

proc padStr(len: int): string =
  result = newString(len)
  result.fill(' ')

proc generateCert() =
  var x509: X509 = X509_new()
  var pkey: EVP_PKEY = EVP_PKEY_new()
  var rsa: RSA = RSA_new()
  var exp: BIGNUM = BN_new()
  var big: BIGNUM = BN_new()
  var serial: ASN1_INTEGER = ASN1_INTEGER_new()

  defer:
    ASN1_INTEGER_free(serial)
    BN_free(big)
    BN_free(exp)
    if not rsa.isNil: RSA_free(rsa)
    EVP_PKEY_free(pkey)
    X509_free(x509)

  template checkErr(err: cint) {.dirty.} =
    if err == 0:
      raise newException(SelfCertError, "self certificate check error")

  template checkErr(retFlag: bool) {.dirty.} =
    if not retFlag:
      raise newException(SelfCertError, "self certificate check error")

  checkErr BN_set_word(exp, RSA_F4)
  checkErr RSA_generate_key_ex(rsa, 2048, exp, nil)
  checkErr BN_pseudo_rand(big, 64, 0, 0)
  BN_to_ASN1_INTEGER(big, serial)
  checkErr X509_set_serialNumber(x509, serial)
  checkErr EVP_PKEY_assign_RSA(pkey, rsa)
  rsa = nil
  checkErr PEM_write_PrivateKey(stdout, pkey, nil, nil, 0, nil, nil)


  checkErr X509_set_version(x509, 2)
  X509_gmtime_adj(X509_get_notBefore(x509), -60 * 60)
  X509_gmtime_adj(X509_get_notAfter(x509), 60 * 60 * 24 * 365 * 10)
  checkErr X509_set_pubkey(x509, pkey)

  var name: X509_NAME = X509_get_subject_name(x509)
  checkErr X509_NAME_add_entry_by_txt(name, "C", MBSTRING_ASC, "JP", -1, -1, 0)
  checkErr X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, "Caprese Self-Signed Certificate", -1, -1, 0)
  checkErr X509_set_issuer_name(x509, name)

  var v3CtxObj: v3_ext_ctx
  var v3Ctx: X509V3_CTX = addr v3CtxObj
  X509V3_set_ctx(v3Ctx, x509, x509, nil, nil, 0)
  var subjectAltName = X509V3_EXT_nconf_nid(nil, v3Ctx, NID_subject_alt_name, "DNS:localhost".cstring)
  checkErr X509_add_ext(x509, subjectAltName, -1)
  X509_EXTENSION_free(subjectAltName)
  var basicConstraints = X509V3_EXT_nconf_nid(nil, v3Ctx, NID_basic_constraints, "critical,CA:FALSE".cstring)
  checkErr X509_add_ext(x509, basicConstraints, -1)
  X509_EXTENSION_free(basicConstraints)
  var subjectKeyIdentifier = X509V3_EXT_nconf_nid(nil, v3Ctx, NID_subject_key_identifier, "hash".cstring)
  checkErr X509_add_ext(x509, subjectKeyIdentifier, -1)
  X509_EXTENSION_free(subjectKeyIdentifier)
  var authorityKeyIdentifier = X509V3_EXT_nconf_nid(nil, v3Ctx, NID_authority_key_identifier, "keyid:always".cstring)
  checkErr X509_add_ext(x509, authorityKeyIdentifier, -1)
  X509_EXTENSION_free(authorityKeyIdentifier)

  checkErr X509_sign(x509, pkey, EVP_sha1())
  checkErr PEM_write_X509(stdout, x509)


  var x509DataLen = i2d_X509(x509, nil)
  var x509Data = newSeq[byte](x509DataLen)
  var pX509Data = addr x509Data[0]
  checkErr i2d_X509(x509, cast[ptr ptr cuchar](addr pX509Data))

  var generatedDate = $now()
  var x509Str = "# Generated by Caprese " & generatedDate & "\n\n"
  x509Str.add """
import bearssl_ssl
import bearssl_x509

"""

  for i, d in x509Data:
    if i == 0:
      x509Str.add "let CERT0 = @[uint8 0x" & d.toHex & ", "
    else:
      if i == x509Data.high:
        x509Str.add "0x" & d.toHex & "]\n\n"
      elif (i + 1) mod 8 == 0:
        x509Str.add "0x" & d.toHex & ",\n" & padStr(20)
      else:
        x509Str.add "0x" & d.toHex & ", "

  x509Str.add """
let CHAIN* = [
    br_x509_certificate(data: cast[ptr uint8](unsafeAddr CERT0[0]), data_len: CERT0.len.csize_t)]

const
  CHAIN_LEN* = 1
"""
  echo "x509Str=", x509Str


  var keyDataLen = i2d_PrivateKey(pkey, nil)
  var keyData = newSeq[byte](keyDataLen)
  var pKeyData = addr keyData[0]
  checkErr i2d_PrivateKey(pkey, cast[ptr ptr cuchar](addr pKeyData))

  var dc: br_skey_decoder_context
  br_skey_decoder_init(addr dc)
  br_skey_decoder_push(addr dc, addr keyData[0], keyData.len.csize_t)
  let decodeLastErr = br_skey_decoder_last_error(addr dc)
  if decodeLastErr != 0:
    raise newException(SelfCertError, "br_skey_decoder_last_error err=" & $decodeLastErr)

  let keyType = br_skey_decoder_key_type(addr dc)
  case keyType
  of BR_KEYTYPE_RSA:
    var rk = br_skey_decoder_get_rsa(addr dc)
    var p = cast[ptr UncheckedArray[byte]](rk.p).toBytes(rk.plen)
    var q = cast[ptr UncheckedArray[byte]](rk.q).toBytes(rk.qlen)
    var dp = cast[ptr UncheckedArray[byte]](rk.dp).toBytes(rk.dplen)
    var dq = cast[ptr UncheckedArray[byte]](rk.dq).toBytes(rk.dqlen)
    var iq = cast[ptr UncheckedArray[byte]](rk.iq).toBytes(rk.iqlen)

    var rsaStr = "# Generated by Caprese " & generatedDate & "\n\n"
    rsaStr.add """
import bearssl_ssl
import bearssl_rsa

"""

    for i, d in p:
      if i == 0:
        rsaStr.add "let RSA_P = @[uint8 0x" & d.toHex & ", "
      else:
        if i == p.high:
          rsaStr.add "0x" & d.toHex & "]\n\n"
        elif (i + 1) mod 8 == 0:
          rsaStr.add "0x" & d.toHex & ",\n" & padStr(20)
        else:
          rsaStr.add "0x" & d.toHex & ", "

    for i, d in q:
      if i == 0:
        rsaStr.add "let RSA_Q = @[uint8 0x" & d.toHex & ", "
      else:
        if i == q.high:
          rsaStr.add "0x" & d.toHex & "]\n\n"
        elif (i + 1) mod 8 == 0:
          rsaStr.add "0x" & d.toHex & ",\n" & padStr(20)
        else:
          rsaStr.add "0x" & d.toHex & ", "

    for i, d in dp:
      if i == 0:
        rsaStr.add "let RSA_DP = @[uint8 0x" & d.toHex & ", "
      else:
        if i == dp.high:
          rsaStr.add "0x" & d.toHex & "]\n\n"
        elif (i + 1) mod 8 == 0:
          rsaStr.add "0x" & d.toHex & ",\n" & padStr(21)
        else:
          rsaStr.add "0x" & d.toHex & ", "

    for i, d in dq:
      if i == 0:
        rsaStr.add "let RSA_DQ = @[uint8 0x" & d.toHex & ", "
      else:
        if i == dq.high:
          rsaStr.add "0x" & d.toHex & "]\n\n"
        elif (i + 1) mod 8 == 0:
          rsaStr.add "0x" & d.toHex & ",\n" & padStr(21)
        else:
          rsaStr.add "0x" & d.toHex & ", "

    for i, d in iq:
      if i == 0:
        rsaStr.add "let RSA_IQ = @[uint8 0x" & d.toHex & ", "
      else:
        if i == iq.high:
          rsaStr.add "0x" & d.toHex & "]\n\n"
        elif (i + 1) mod 8 == 0:
          rsaStr.add "0x" & d.toHex & ",\n" & padStr(21)
        else:
          rsaStr.add "0x" & d.toHex & ", "

    rsaStr.add """
let RSA* = br_rsa_private_key(n_bitlen: 2048.cuint,
                              p: cast[ptr uint8](unsafeAddr RSA_P[0]), plen: RSA_P.len.csize_t,
                              q: cast[ptr uint8](unsafeAddr RSA_Q[0]), qlen: RSA_Q.len.csize_t,
                              dp: cast[ptr uint8](unsafeAddr RSA_DP[0]), dplen: RSA_DP.len.csize_t,
                              dq: cast[ptr uint8](unsafeAddr RSA_DQ[0]), dqlen: RSA_DQ.len.csize_t,
                              iq: cast[ptr uint8](unsafeAddr RSA_IQ[0]), iqlen: RSA_IQ.len.csize_t)
"""
    echo rsaStr
    zeroMem(addr dc, sizeof(br_skey_decoder_context))

    writeFile(curSrcPath / "bearssl/generated_chain_rsa.nim", x509Str)
    writeFile(curSrcPath / "bearssl/generated_key_rsa.nim", rsaStr)

  of BR_KEYTYPE_EC:
    raise newException(SelfCertError, "self certificate BR_KEYTYPE_EC key type")

  else:
    raise newException(SelfCertError, "self certificate unknown key type")


generateCert()
